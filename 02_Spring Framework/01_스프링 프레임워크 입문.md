# 스프링 프레임워크 입문

- '스프링 프레임워크 입문 강좌' 및 '예제로 배우는 스프링 입문 (개정판)' 강의 내용
- Github Spring 공식 프로젝트 Petclinic 사용
  - 일반적인 메이븐 프로젝트
  - 스프링 부트 기반 프로젝트



## IoC (Inversion of Control)

- 의존성 역전
- Controller 의 생성자를 통해 Repository 주입

### IoC 컨테이너

- ApplicationContext Interface를 통해 사용
- IoC 컨테이너 내부에 Controller, Repository 객체(빈)가 만들어진다.

- 빈을 만들고 엮어주며 제공해 준다. (빈 의존성 관리)



## 빈 (Bean)

- Spring IoC Container 가 관리하는 객체

### 등록방법

- Component Scanning - Annotation 을 통한 등록
  - @Component
    - @Repository
    - @Service
    - @Controller
  - @Bean
    - 반드시 @Configuration 이 선언 된 클래스 내부에서 사용되어야 함.
- XML 또는 Java 설정 파일을 통해 등록

### 사용방법

- @Autowired 또는 @Inject Annotation 사용
- ApplicationContext 에서 getBean() 함수를 통해 꺼내서 사용



## 의존성 주입

- 빈이 되는 클래스에 생성자가 하나만 있고, 빈으로 선언 된 것을 매개변수로 받는 다면, 자동으로 주입. (@Autowired 가 생략되어 있는 것)
- 변수 선언에 @Autowired 사용
- Setter 에 사용
- 생성자 > Setter > @Autowired 순으로 권장



## AOP (Aspect Oriented Programming)

- 흩어진 코드를 한 곳으로 모으는 개념.

- 함수 모듈화 개념의 코딩 기법

### 예제

- 로그 작성 기능 개발 예제

- @LogExecutionTime Custom Annotation 을 통해 메소드 처리 시간 로깅

- ```java
  import java.lang.annotation.ElementType;
  import java.lang.annotation.Retention;
  import java.lang.annotation.RetentionPolicy;
  import java.lang.annotation.Target;
   
  @Target(ElementType.METHOD)
  @Retention(RetentionPolicy.RUNTIME)
  public @interface LogExecutionTime {
  }
  ```

  **@Target(ElementType.METHOD)**

  애노테이션을 메소드에 사용할 것이라고 설정한다.

   

  **@Retention(RetentionPolicy.RUNTIME)**

  애노테이션이 RUNTIME까지 유지되도록 설정한다.

  

- 실제 Aspect

- ```java
  import org.aspectj.lang.ProceedingJoinPoint;
  import org.aspectj.lang.annotation.Around;
  import org.aspectj.lang.annotation.Aspect;
  import org.slf4j.Logger;
  import org.slf4j.LoggerFactory;
  import org.springframework.stereotype.Component;
  import org.springframework.util.StopWatch;
   
  @Component
  @Aspect
  public class LogAspect {
      
      Logger logger = LoggerFactory.getLogger(LogAspect.class);
      
      @Around("@annotation(LogExecutionTime)")
      public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
          StopWatch stopWatch = new StopWatch();
          stopWatch.start();
          
          // @LogExecutionTime 애노테이션이 붙어있는 타겟 메소드를 실행
          Object proceed = joinPoint.proceed();
          
          stopWatch.stop();
          logger.info(stopWatch.prettyPrint());
          
          return proceed; // 결과 리턴
      }
  }
  
  ```

  **Logger logger = LoggerFactory.getLogger(LogAspect.class);**

  slf4j로 로거를 만든다.

   

  **@Around("@annotation(LogExecutionTime)")**

  이 애노테이션을 붙인 메소드에서는 ProceedingJoinPoint 파라미터를 받을 수 있다.

  애노테이션의 value를 "@annotation(LogExecutionTime)"로 지정함으로서

  joinPoint는 @LogExecutionTime를 붙인 타겟 메소드를 의미하게 된다.

   

  **Object proceed = joinPoint.proceed();**

  타겟 메소드를 실행한다.

  이 라인 앞 뒤로 StopWatch를 이용한 메소드 성능 측정 코드를 넣어준다.

- 빈에서 @LogExecutionTime Custom Annotation 선언을 통해 사용



## PSA (Portable Service Abstraction)

- 잘 만든 인터페이스
- PSA를 통해 코딩 된 코드는 이후 테스트 및 확장성이 용이하다.

- Spring 이 제공해주는 대부분의 API가 PSA이다.